TUPLAS 
- É a estrutura fundamental para agrupar um número fixo de valores que podem ser de tipos
diferentes em um único valor composto.

- Ex: 
  . representar ponto 2D: (Coordenada X, Coordenada Y)
  . representar uma pessoa: (Nome, Idade)

- Sintaxe: Valores entre parênteses, separados por vírgula

- Ex:
  . (”Ada”, 1815) :: (String, Integer)
  . (True, 'a', 3.0) :: (Bool, Char, Double)

- Ordem importa. (String, Int) é diferente de (Int, String)

- Número de elementos também faz parte do tipo

- A tupla de zero elementos () tem o tipo (), chamado tipo unitário.
  . Similar ao void: usado quando um valor é necessário sintaticamente, mas nenhuma informação real precisa ser transmitida

- Para tuplas de 2 elementos (pares), o Prelude oferece:
  . fst :: (a, b) -> a -- resulta no primeiro componente
  . snd :: (a, b) -> b -- resulta no segundo componente
  . OBS: fst e snd funcionam apenas para pares


LISTAS
- A estrutura de dados mais comum em Haskell. É uma sequência de valores de um único tipo (homogênea) e de tamanho variável.

- Tipo: [TipoDoElemento]. 
  . Ex: [Int], [Bool], [String].

- Sintaxe:Elementos entre colchetes, separados por vírgula. A lista vazia é [].
  . [1, 2, 3] :: [Int]
  . ['x', 'y'] :: [Char]
  . [] :: [a]

- Notação Fundamental
  . Utiliza o construtor :
  . Cabeça a esquerda e cauda a direita
  . [8] == 8 : []
  . ['x', 'y'] == 'x' : ['y'] == 'x' : 'y' : []
  . [1, 2, 3] == 1 : 2 : 3 : []

- Progressões
  . Para tipos enumeráveis podemos criar listas com a sintaxe ..
  . Ex:
    [1..5]       ->  [1, 2, 3, 4, 5]
    ['a'..'d']   ->  ”abcd”
    [2, 4 .. 10] ->  [2, 4, 6, 8, 10]
    [5, 4 .. 1]  ->  [5, 4, 3, 2, 1]
    [1..]        ->  Lista infinita: [1, 2, 3, ...]

- Operações Com Listas
  . Acesso e Tamanho
    head [1,2,3]     ->  1
    tail [1,2,3]     ->  [2,3]
    last [1,2,3]     ->  3
    init [1,2,3]     ->  [1,2]
    [1,2,3] !! 1     ->  2 (selecionar o elemento de índice 1 na lista)
    length [1,2,3,4] ->  4
    null []          ->  True

  . Manipulação
    reverse[1,2,3]   -> [3,2,1]
    [1,2] ++ [3,4,5] -> [1,2,3,4,5]
    take 2 [1,2,3]   -> [1,2]
    drop 2 [1,2,3]   -> [2]

  . OBS: Operações na cabeça (head, tail, :) são O(1) (muito rápidas). Operações que precisam percorrer a lista (last, length, ++) são O(n) (mais lentas para listas grandes).


STRINGS
- Em Haskell, o tipo String é simplesmente um tipo sinônimo para [Char] (uma lista de caracteres).
  . type String = [Char]
  . ”FP” -- é exatamente o mesmo que ['F', 'P']
  . ”” -- é exatamente o mesmo que []

- As operações com listas podem também ser feitas com Strings


VALORES OPCIONAIS
- E se uma função pode falhar ou não ter um resultado significativo para retornar?
  . Ex: 
    Dividir por zero.
    Buscar um elemento que não existe numa coleção.
    Ex: Acessar a cabeça de uma lista vazia.

  . Linguagens como Java/Python usam null ou exceções, o que pode levar a erros em tempo de execução (NullPointerException)
 
- A Solução de Haskell: O Tipo Maybe
  . Haskell usa o sistema de tipos para representar a possibilidade de ausência de valor de forma explícita e segura.
  . O tipo Maybe a pode conter um valor do tipo a ou representar a ausência de valor
    data Maybe a = Nothing | Just a
    Nothing: Representa a ausência de um valor. É a estrutura maybe vazia
    Just valor: Contém um valor do tipo a, indicando a presença de um resultado

  . O tipo Maybe a é diferente do tipo a. Você não pode usar um Maybe Int diretamente onde um Int é esperado. Isso força o programador a tratar explicitamente o caso Nothing.

- Funções úteis para trabalhar com valores Maybe. (Precisa de import Data.Maybe)isJust Verifica se é Just x.
  . isJust: verifica se é Just x
    isJust (Just 10) -> True

  . fromJust Extrai o valor de Just x. Erro se for Nothing!
    fromJust (Just 10) ->  10

  . fromMaybe Usa um valor padrão se for Nothing.
    fromMaybe 0 (Just 10) -> 10
    fromMaybe 0 Nothing   -> 0

  . Prefira fromMaybe a maybeValor.

  . Use fromJust apenas se tiver certeza absoluta (por exemplo, após um teste com isJust) que o valor não é Nothing.


MODELAGEM DE DADOS
- É o processo de escolher as estruturas de dados (tuplas, listas, Maybe) e tipos (básicos, sinônimos) adequados para representar informações do mundo real de forma clara e precisa no nosso programa.
  . Usamos type para criar sinônimos que dão significado semântico aos tipos.
  . Combinamos as estruturas para criar representações mais ricas.
  . Ex: Ponto Cartesiano
    type Ponto = (Double, Double)

    origem :: Ponto
    origem = (0.0, 0.0)

    ponto1 :: Ponto
    ponto1 = (1.5, -5.3)

  . Ex2: Cadastro de Pessoa
    type Nome = String
    type Idade = int
    type Pessoa = (Nome, Maybe Idade)

    pessoa1 :: Pessoa
    pessoa1 = ("joao", Just 25)




