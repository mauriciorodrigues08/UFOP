ARQUIVOS
- processamento lento
- grava os dados em disco

ARQUIVO TEXTO
- armazena caracteres seguindo uma codificação (ex: utf-8)
- texto qualquer digitado no bloco de notas
- 

ARQUIVO BINÁRIO
- sequência de bits ordenada
- ex: arquivos exe, compactados, registros, etc

COMANDOS DA BIBLIOTECA stdio.h
- tipo arquivo: FILE
- na prática utilizamos um ponteiro para o tipo FILE

- arquivo para leitura
  FILE *entrada;

- arquivo para gravação
  FILE saida;

- comando fopen() é usado para abrir um arquivo
  FILE * fopen(const char "filename", const char "mode"); 
  . "filename" é o nome do arquivo a ser aberto
  . mode:
    "r" (read): leitura (arquivo tem que existir)
    "w" (write): gravação (sobrescreve o arquivo, se existir ou cria um novo arquivo)
    "r+" (read/update): leitura e gravação (arquivo tem que existir)
    "w+" (write/read): leitura e gravação (cria arquivo se não existir)
    "a+" (append/update): acrescenta dados no arquivo

- o comando fclose() é usado para fechar um arquivo
  int fclose(FILE *stream)
  . stream é o nome do ponteiro para o arquivo
  . fechar apenas após o final da utilização do arquivo
  . retorna 0 em caso de sucesso e EOF (-1) caso contrário

- exemplo de uso fopen() e fclose():
  FILE *arquivo = fopen("file.txt", "r"); //modo leitura
  /* utilização do conteúdo do arquivo */
  fclose(arquivo);

- o comando fprintf() é usado para printar no arquivo
  int fprintf(FILE *stream, const char *format, ...);
  . funcionamento muito semelhante ao printf()
  . exemplo:
    FILE *arquivo = fopen("texto.txt", "w");

    //escrevendo texto e número inteiro no arquivo
    int n = 10;
    fprintf(arquivo, "O valor de n é %d\n", n);

    fclose(arquivo);

- o comando fscanf() é usado para ler conteúdos do arquivo
  . int fscanf(FILE *stream, const char *format, ...);
  . funcionamento muito semelhante ao scanf()
  . a função retorna o número de argumentos preenchidos  ou EOF se o fim do arquivo for atingido
  . exemplo:
    FILE *arquivo = fopen("texto.txt", "r");

    //lendo um inteiro e um caracter separados por um espaço
    int inteiro;
    char caracter;
    fscanf(arquivo, "%d %c", &inteiro, &caracter);

    fclose(arquivo);

- outras funções da biblioteca <stdio.h>
  . char *fgets(char *str, int num, FILE *stream);
  //lê uma linha, incluindo o '\n' de um arquivo

  . int fgetc(FILE *stream);
  //lê um caractere e retorna como um inteiro

  . int feof(FILE *stream);
  //retorna 0 se a posição atual não for o fim do arquivo e um valor diferente de 0 caso contrário

  . int fputs(const char *str, FILE *stream);
  //escreve uma string no arquivo, retorna EOF em caso de erro

  . int fputc(int caractere, file *stream);
  //escreve um caractere no arquivo, retorna EOF em caso de erro

  . fflush(FILE *stream);
  //grava os dados do buffer no arquivo e limpa o buffer de gravação

ARQUIVOS BINÁRIOS
- é aberto com fopen() de maneira quase idêntica ao arquivo texto
  . sintaxe do fopen() para BINÁRIOS
  . FILE* fopen(const char *filename, const char mode); //a diferença está no modo de abertura
  . modos para arquivos binários:
    "rb" (read binary): leitura
    "wb" (write binary): gravação
    "rb+" (read/update binary): leitura e atualização
    "wb+" (write/read binary): leitura e gravação
    "ab+" (append/update binary): atualização

- fechamento do arquivo ocorre da mesma maneira do arquivo texto
  . int fclose(FILE *stream)

- exemplo:
  FILE *arquivo = fopen("arquivo.dat", "rb");
  /*utilização do arquivo*/
  fclose(arquivo);

- gracação de bytes será feita pelo comando fwrite()
  . sintaxe
    site_t fwrite(const void *ptr, size_t size, size_t count, FILE *file);
  
  . exemplo
    FILE *arquivo = fopen("texto.dat", "wb");

    int n = 10;

    //esse comando vai escrever o número n, 1 vez, em "arquivo"
    fwrite(&n, sizeof(int), 1, arquivo)

    fclose(arquivo);

- leitura de bytes será feita pelo comando fread()
  . sintaxe
    size_t fread(void *ptr, size_t size, size_t count, FILE *file);

  . exemplo
    FILE *arquivo = fopen("texto.dat", "rb");

    int inteiro;
    char caractere;

    fread(&inteiro, sizeof(int), 1, arquivo);
    fread(&caractere, sizeof(char), 1, arquivo);

    fclose(arquivo);

NAVEGANDO EM ARQUIVOS 
- a função fseek() reposiciona o "cursor" no lugar desejado do arquivo
  . sintaxe
    int fseek(FILE *file, long int offset, int whence);
  
  . a função retorna 0 em caso de sucesso e outro valor caso contrário
  . FILE *file: ponteiro para o arquivo
  . offset: quantidade de bytes de deslocamento (pode-se usar números negativos)
  . whence: indica de onde o deslocamento é feito
    SEEK_SET: início do arquivo
    SEEK_CUR: posição atual do "cursor" no arquivo
    SEEK_END: fim do arquivo

- a função ftell() retorna a posição atual do "cursor"
  . retorana a posição em bytes
  . sintaxe
    long int ftell(FILE *file);

- obs: essas funções valem tanto para arquivos texto quanto binários

- exemplo de utilização
    FILE *arquivo = fopen("texto.dat", "rb");

    //move o cursor para o final do arquivo
    fseek(arquivo, 0, SEEK_END);

    //captura a posição atual no arquivo
    long int tamanho = ftell(arquivo);

    printf("A leitura do arquivo "texto.txt" está na posição %ld\n", tamanho);

    fclose(arquivo);