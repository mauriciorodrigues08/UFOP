VALORES 
- A computação em Haskell é a avaliação de expressões

- Uma expressão é avaliada até se tornar um valor, um estado final que não pode ser mais reduzido

- Os valores são escritos usando duas sintaxes:
   . Notações que representam a si mesmas
	123, 0xFF (Inteiros)
	3.14 (Fracionário)
	'a' (Caractere)
	”Texto” (String)

   . Nomes ou símbolos que representam valores.
	True, False
	[] (lista vazia)
	() (valor unitário)
	Regra de ouro: começam com letra maiúscula!


DEFINIÇÕES
- Variáveis: Lado esquerdo contém o nome e o lado direito o valor
   . piAproximado = 3.14159

- Funções:  Lado esquerdo contém o nome e os parâmetros e lado direito expressão.
   . areaCirculo raio = piAproximado * raio^2

APLICAÇÃO DE FUNCÕES
- Aplicar uma função consiste em escrever o seu nome, seguido de seus argumentos, separados por espaços. Sem parênteses, sem vírgulas!
   . sqrt 25 -- Resulta em 5.0
   . logBase 2 1024 -- Resulta em 10.0
   . mod 10 3 -- Resulta em 1

- Utilização de parênteses
   . Apenas para agrupar subexpressões, forçar uma ordem
   . Ex:
	Primeiro calcula logBase, depois sqrt do resultado
	sqrt (logBase 2 1024) -- Resulta em 3.1622

	Primeiro calcula sqrt, depois usa o resultado como base
	logBase (sqrt 4) 16 -- Resulta em 4.0


NOTAÇÃO INFIXA E PRECEDÊNCIA
- Funções simbólicas, como +, *, ==, &&, são escritas entre seus argumentos para maior legibilidade.
   . Ex: 3 + 4 * 5 -- Resulta em 23

- Regras de Avaliação
   . Precedência: Prioridade (0-9).
	Ex: * (prioridade 7) tem prioridade sobre o + (prioridade 6)

   . Associatividade: Direção de agrupamento (esquerda, direita).

- A chamada de função prefixa (f x) tem a precedência mais alta de todas
   . Ex: succ 9 + 2 * max 5 7 - 1
     A ordem de execução é (succ 9) + 2 * (max 5 7) - 1


FLEXIBILIDADE DE NOTAÇÕES
- Coloque um operador entre parênteses para usá-lo como uma função normal.
   . (+) 3 5 -- Resulta em 8
   . (==) 10 10 -- Resulta em True

- Coloque uma função de dois argumentos entre crases para usá-la como um operador.
   . 10 `mod` 3 -- Resulta em 1
   . 1024 `logBase` 2 -- Resulta em 10.0


DEFINIÇÕES LOCAIS

Where
- Exemplo: Área do Triângulo pela Fórmula de Heron
   . Tradução literal é ineficiente
	areaTriangulo a b c =
       	  sqrt (((a+b+c)/2) * (((a+b+c)/2)-a) * (((a+b+c)/2)-b) * (((a+b+c)/2)-c))

   . Melhor método: criação de auxiliares
	areaTriangulo a b c = sqrt (s * (s-a) * (s-b) * (s-c))
	  where
	    s = (a + b + c) / 2

   . Vantagens:
	Legível: O código agora reflete a fórmula matemática.
	Eficiente: s é calculado apenas uma vez.
	Escopo: O nome s só existe dentro de areaTriangulo.

Let ... in
- Calcular as raízes de uma equação quadrática	
  raizes a b c =
    let delta = b^2 - 4*a*c
      x1 = (-b + sqrt delta) / (2*a)
      x2 = (-b - sqrt delta) / (2*a)
    in (x1, x2)

Let... in X Where
- let...in:
   . É uma expressão.
   . Ideal para definições muito locais, dentro de uma expressão maior.

- where:
   . É uma cláusula anexa a uma equação.
   . Ideal para funções auxiliares a uma definição inteira.


REGRA DE LAYOUT
- É a regra que permite ao compilador entender blocos de código com base na indentação, eliminando a necessidade de {} e ;

